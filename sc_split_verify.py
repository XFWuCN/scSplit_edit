"""
Reference free AF-based demultiplexing on pooled scRNA-seq
Jon Xu (jun.xu@uq.edu.au)
Lachlan Coin
Aug 2018
"""

import vcf  # https://pyvcf.readthedocs.io/en/latest/INTRO.html
import numpy as np
import pandas as pd
from scipy.stats import binom
from scipy.sparse import csr_matrix
import datetime
import csv


def main():

    # input and output files
    ori_vcf = 'input8.vcf'        # original vcf file used in demuxlet run
    ref_csv = 'ref_sim8.csv'      # reference matrix
    alt_csv = 'alt_sim8.csv'      # alternative matrix
    psc_csv = 'P_s_c.csv'         # P(s|c) generated by sc_split
    dem_grp = 'd'                 # prefix of demuxlet assignments

    ref = pd.read_csv(ref_csv, header=0, index_col=0)
    alt = pd.read_csv(alt_csv, header=0, index_col=0)
    ref_s = csr_matrix(ref.values)
    alt_s = csr_matrix(alt.values)
    all_POS = ref.index

    # build matrix from scSplit assignment
    P_s_c = pd.read_csv(psc_csv, header=0, index_col=0)
    A_s_c = ((P_s_c >= 0.9) * 1).astype('float64')
    num = len(P_s_c.columns)  # number of samples + 1 doublet state
    err = 0.01  # error rate assumption
    # binomial simulation for genotype likelihood P(D|AA,RA,RR) with the alt count vs total count condition and (err, 0.5, 1-err) as allele probability
    # rr/ra/aa: GL, prr/pra/paa: GP
    rr = pd.DataFrame(binom.logpmf(pd.DataFrame(alt_s.dot(A_s_c)), pd.DataFrame((alt_s + ref_s).dot(A_s_c)), err), index=all_POS, columns=range(num)).drop(0,1)
    ra = pd.DataFrame(binom.logpmf(pd.DataFrame(alt_s.dot(A_s_c)), pd.DataFrame((alt_s + ref_s).dot(A_s_c)), 0.5), index=all_POS, columns=range(num)).drop(0,1)
    aa = pd.DataFrame(binom.logpmf(pd.DataFrame(alt_s.dot(A_s_c)), pd.DataFrame((alt_s + ref_s).dot(A_s_c)), 1-err), index=all_POS, columns=range(num)).drop(0,1)
    prr = 1 / (1 + (ra - rr).apply(np.exp) + (aa - rr).apply(np.exp))
    pra = 1 / (1 + (rr - ra).apply(np.exp) + (aa - ra).apply(np.exp))
    paa = 1 / (1 + (rr - aa).apply(np.exp) + (ra - aa).apply(np.exp))
    prr = (prr > 0.99) * 1
    pra = (pra > 0.99) * 2
    paa = (paa > 0.99) * 3
    scsplit = prr + pra + paa
    
    # build matrix from demuxlet assignment
    for n in range(1, num):
        dem_result = []
        for line in open(dem_grp+str(n), 'r'):
            dem_result.append(line.strip())  # barcodes for each sample
        rr.loc[:, n] = binom.logpmf(alt.loc[:,dem_result].sum(axis=1), (alt+ref).loc[:,dem_result].sum(axis=1), err)
        ra.loc[:, n] = binom.logpmf(alt.loc[:,dem_result].sum(axis=1), (alt+ref).loc[:,dem_result].sum(axis=1), 0.5)
        aa.loc[:, n] = binom.logpmf(alt.loc[:,dem_result].sum(axis=1), (alt+ref).loc[:,dem_result].sum(axis=1), 1-err)
    prr = 1 / (1 + (ra - rr).apply(np.exp) + (aa - rr).apply(np.exp))
    pra = 1 / (1 + (rr - ra).apply(np.exp) + (aa - ra).apply(np.exp))
    paa = 1 / (1 + (rr - aa).apply(np.exp) + (ra - aa).apply(np.exp))
    prr = (prr > 0.99) * 1
    pra = (pra > 0.99) * 2
    paa = (paa > 0.99) * 3
    demuxlet = prr + pra + paa

    # build matrix from original vcf                                    ### problematic as the SNVs in the ori_vcf is different from the ref/alt matrices
    prr[:] = pra[:] = paa[:] = 0    
    for record in vcf.Reader(open(ori_vcf, 'r')):
        pos = record.CHROM + ':' + str(record.POS)
        if pos in list(prr.index):
            for n in range (1, num):
                if record.samples[n-1]['GP'][0] > 0.99:
                    prr.loc[pos, n] = 1
                elif record.samples[n-1]['GP'][1] > 0.99:
                    prr.loc[pos, n] = 2
                elif record.samples[n-1]['GP'][2] > 0.99:
                    prr.loc[pos, n] = 3
    vcf_all = prr + pra + paa

    # output
    scsplit.to_csv('verify_scsplit.csv')
    demuxlet.to_csv('verify_demuxlet.csv')
    vcf_all.to_csv('verify_reference.csv')

if __name__ == '__main__':
    main()
